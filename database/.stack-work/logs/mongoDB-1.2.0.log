Configuring mongoDB-1.2.0...
Building mongoDB-1.2.0...
Preprocessing library mongoDB-1.2.0...

System/IO/Pipeline.hs:5:14: warning:
    -XDoRec is deprecated: use -XRecursiveDo or pragma {-# LANGUAGE RecursiveDo #-} instead
[1 of 8] Compiling System.IO.Pool   ( System/IO/Pool.hs, .stack-work/dist/x86_64-osx/Cabal-1.24.0.0/build/System/IO/Pool.o )

System/IO/Pool.hs:11:1: warning: [-Wdeprecations]
    Module ‘Control.Monad.Error’ is deprecated:
      Use Control.Monad.Except instead

System/IO/Pool.hs:17:1: warning: [-Wtabs]
    Tab character found here, and in 26 further locations.
    Please use spaces instead.

System/IO/Pool.hs:17:24: warning: [-Wdeprecations]
    In the use of type constructor or class ‘ErrorT’
    (imported from Control.Monad.Error, but defined in transformers-0.5.2.0:Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

System/IO/Pool.hs:32:15: warning: [-Wdeprecations]
    In the use of type constructor or class ‘Error’
    (imported from Control.Monad.Error, but defined in transformers-0.5.2.0:Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"

System/IO/Pool.hs:32:39: warning: [-Wdeprecations]
    In the use of type constructor or class ‘ErrorT’
    (imported from Control.Monad.Error, but defined in transformers-0.5.2.0:Control.Monad.Trans.Error):
    Deprecated: "Use Control.Monad.Trans.Except instead"
[2 of 8] Compiling System.IO.Pipeline ( System/IO/Pipeline.hs, .stack-work/dist/x86_64-osx/Cabal-1.24.0.0/build/System/IO/Pipeline.o )

System/IO/Pipeline.hs:57:9: error:
    • Variable not in scope:
        addMVarFinalizer :: MVar (IOStream i o) -> IO () -> IO a0
    • Perhaps you want to add ‘addMVarFinalizer’ to the import list
      in the import of ‘Control.Concurrent’
      (System/IO/Pipeline.hs:17:1-56).

System/IO/Pipeline.hs:99:9: error:
    • Non type-variable argument
        in the constraint: Control.Monad.Base.MonadBase IO m
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        doCall :: forall i1 (m :: * -> *).
                  Control.Monad.Base.MonadBase IO m =>
                  IOStream i1 o -> ErrorT IOError IO (ErrorT IOError m i)
      In an equation for ‘call’:
          call p@(Pipeline {..}) message
            = withMVar vStream doCall `onException` close p
            where
                doCall stream
                  = do { writeStream stream message;
                         .... }
